import { GetTasksResult } from './../../../../shared/types/types';
import { ToastService } from './toast.service';
import { Property, User, GetChecklistsResult, Checklist, Inspection, Category, GetInspectionsResult, CreateTaskResult } from 'shared';
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { map, catchError } from 'rxjs/operators';
import { Store, Action } from './store/store.service';
import { Observable, zip } from 'rxjs';
import { LoadingService } from '@fivethree/core';
import { sortChecklists } from './api.service';
import { environment } from '@environments/environment';

@Injectable({
  providedIn: 'root'
})
export class DataService {

  private users = `${environment.baseURL}/users`;
  private properties = `${environment.baseURL}/properties`;
  private checklists = `${environment.baseURL}/checklisttemplates`;
  private adminchecklists = `${environment.baseURL}/adminchecklisttemplates`;
  private categories = `${environment.baseURL}/pruefkriteriencategories`;
  private hausverwalter = `${environment.baseURL}/users/hausverwalter`;
  private inspections = `${environment.baseURL}/inspections`;
  private openinspections = `${environment.baseURL}/openinspections`;


  constructor(public store: Store,
    public http: HttpClient,
    public loading: LoadingService,
    public toast: ToastService) {

  }

  loadUsers(): Observable<User[]> {
    const users = this.store.select('users');
    const mitarbeiter = this.store.select('mitarbeiter');
    this.reloadUsers();

    return zip(users, mitarbeiter)
      .pipe(
        map(data => [...data[0] || [], ...data[1] || []]),
        map(us => us.sort((a: User, b: User) => {
          return b.id - a.id;
        }))
      );

  }

  reloadUsers() {
    this.http.get(`${this.users}`)
      .pipe(
        catchError(err => {
          this.onUsersError();
          return this.store.select('users');
        })
      ).subscribe((uss) => {
        this.store.dispatch(new Action('UPDATE', uss));
      });
  }

  loadHausverwalter(): Observable<User[]> {
    const mitarbeiter = this.store.select('hausverwalter');
    this.reloadHausverwalter();

    return mitarbeiter
      .pipe(
        map(cs => !cs ? [] : cs),
        map(us => us.sort((a: User, b: User) => {
          return b.id - a.id;
        }))
      );

  }

  reloadHausverwalter() {
    this.http.get(`${this.hausverwalter}`)
      .pipe(
        catchError(err => {
          this.onUsersError();
          return this.store.select('hausverwalter');
        })
      ).subscribe((uss) => {
        console.log('hausverwalter', uss);
        this.store.dispatch(new Action('UPDATE', uss));
      });
  }

  loadCategories(): Observable<Category[]> {
    const cats = this.store.select('kriterien');
    this.reloadCategories();
    return cats;
  }

  reloadCategories() {
    this.http.get(`${this.categories}`)
      .pipe(
        catchError(err => {
          this.onCategoriesError();
          return this.store.select('kriterien');
        })
      ).subscribe((cats) => {
        this.store.dispatch(new Action('UPDATE', cats));
      });
  }

  loadProperties(): Observable<Property[]> {
    const properties = this.store.select('properties');
    this.reloadProperties();

    return properties
      .pipe(
        map(cs => !cs ? [] : cs),
        map(ps => ps.sort((a: Property, b: Property) => {
          return b.id - a.id;
        })));

  }

  reloadProperties() {
    this.http.get(`${this.properties}`)
      .pipe(
        catchError(err => {
          this.onPropertiesError();
          return this.store.select('properties');
        })
      ).subscribe((props) => {
        this.store.dispatch(new Action('UPDATE', props));
      });
  }

  loadChecklists(): Observable<Checklist[]> {
    const checklists = this.store.select('checklists');
    this.reloadChecklists();

    return checklists
      .pipe(
        map(cs => !cs ? [] : cs),
        sortChecklists()
      );

  }

  reloadChecklists() {
    this.http.get<GetChecklistsResult>(`${this.checklists}`)
      .pipe(
        map((data: GetChecklistsResult) => data.checklists),
        sortChecklists(),
        catchError(err => {
          this.onChecklistsError();
          return this.store.select('checklists');
        })
      ).subscribe((checks) => {
        this.store.dispatch(new Action('UPDATE', { 'checklists': checks }));
      });
  }

  loadAdminChecklists(): Observable<Checklist[]> {
    const checklists = this.store.select('adminchecklists');
    this.reloadAdminChecklists();

    return checklists
      .pipe(
        map(cs => !cs ? [] : cs),
        sortChecklists(),
        map(cs => cs.sort((a: Checklist, b: Checklist) => {
          return b.id - a.id;
        })));

  }

  reloadAdminChecklists(): any {
    this.http.get<GetChecklistsResult>(`${this.adminchecklists}`)
      .pipe(
        map((data: GetChecklistsResult) => data.checklists),
        sortChecklists(),
        catchError(err => {
          this.onChecklistsError();
          return this.store.select('adminchecklists');
        })
      ).subscribe((checks) => {
        this.store.dispatch(new Action('UPDATE', { 'adminchecklists': checks }));
      });
  }

  loadInspections(): Observable<Inspection[]> {
    const checklists = this.store.select('inspections');
    this.reloadInspections();
    return checklists;
  }

  reloadInspections() {
    const closed = this.http.get<GetInspectionsResult>(`${this.inspections}`)
      .pipe(
        map((data: GetInspectionsResult) => data.inspections),
      );

    const open = this.http.get<GetInspectionsResult>(`${this.openinspections}`)
      .pipe(
        map((data: GetInspectionsResult) => data.inspections),
      );

    zip(closed, open)
      .pipe(
        map(data => [...data[0] || [], ...data[1] || []]),
        catchError(err => {
          this.onInspectionsError();
          return this.store.select('inspections');
        })
      ).subscribe((checks) => {
        console.log('checks', checks);
        this.store.dispatch(new Action('UPDATE', { 'inspections': checks }));
      });
  }

  onPropertiesError() {
    this.toast.presentToast(8000, `Immobilien konnten nicht aktualisiert werden`, 'Erneut versuchen').then(toast => {
      if (toast.role === 'cancel') {
        this.reloadProperties();
      }
    });
  }
  onInspectionsError() {
    this.toast.presentToast(8000, `Begehungen konnten nicht aktualisiert werden`, 'Erneut versuchen').then(toast => {
      if (toast.role === 'cancel') {
        this.reloadInspections();
      }
    });
  }
  onChecklistsError() {
    this.toast.presentToast(8000, `Immobilien konnten nicht aktualisiert werden`, 'Erneut versuchen').then(toast => {
      if (toast.role === 'cancel') {
        this.reloadChecklists();
      }
    });
  }
  onUsersError() {
    this.toast.presentToast(8000, `Immobilien konnten nicht aktualisiert werden`, 'Erneut versuchen').then(toast => {
      if (toast.role === 'cancel') {
        this.reloadUsers();
      }
    });
  }
  onCategoriesError() {
    this.toast.presentToast(8000, `Kategorien konnten nicht geladen werden`, 'Erneut versuchen').then(toast => {
      if (toast.role === 'cancel') {
        this.reloadCategories();
      }
    });
  }
}
