import { ApiService } from './../../services/api.service';
import { AlertController, ModalController } from '@ionic/angular';
import { Component, OnInit, Input, Output, EventEmitter, ViewChild, ElementRef } from '@angular/core';
import { Checklist, UploadPictoResult, GetPictoBase64Result, Property } from 'shared';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { first, tap, flatMap, map } from 'rxjs/operators';
import { ToastService } from '@services/toast.service';
import { TokenService } from '@services/token/token.service';
import { DomSanitizer, SafeResourceUrl } from '@angular/platform-browser';
import { FivExpandable, FivLoadingProgressBar } from '@fivethree/core';
import { EditableComponent } from '@components/editable/editable.component';
import { PictosPage } from '@components/pictos/pictos.page';

@Component({
  selector: 'app-kriterium',
  templateUrl: './kriterium.component.html',
  styleUrls: ['./kriterium.component.scss'],
  animations: [
    trigger('rotate', [
      state('normal', style({ transform: 'rotateZ(0)' })),
      state('rotate', style({ transform: 'rotateZ(180deg)' })),
      transition('normal => rotate', [
        animate('200ms ease-in')
      ]),
      transition('rotate => normal', [
        animate('175ms ease-out')
      ])
    ])
  ]
})
export class KriteriumComponent implements OnInit {

  @Input() checklist: Checklist;
  @Input() property: Property;
  @Input() level: number;
  @Input() kriterium: number;
  @Input() isAdmin: boolean;
  @Output() kriteriumDeleted = new EventEmitter<Checklist>();
  @Output() fivChange = new EventEmitter<Checklist>();

  image: UploadPictoResult;
  imageData: SafeResourceUrl;
  authToken: string;

  @ViewChild('fileInput') fileInput: ElementRef;


  constructor(private alertController: AlertController,
    private api: ApiService,
    private token: TokenService,
    private dom: DomSanitizer,
    private modal: ModalController,
    public toast: ToastService) { }

  ngOnInit() {
    this.authToken = this.token.getToken();
    this.loadImage();
  }

  async presentAlertConfirm() {
    const alert = await this.alertController.create({
      header: `Löschen bestätigen`,
      message: `Soll der Prüfbereich <strong>${this.checklist.levels[this.level].kriterien[this.kriterium].name} </strong> wirklich gelöscht werden?`,
      buttons: [
        {
          text: 'Abbrechen',
          role: 'cancel',
          cssClass: 'secondary',
        }, {
          text: 'Löschen',
          handler: () => {
            this.delete();
          }
        }
      ]
    });

    await alert.present();
  }

  delete() {
    if (this.isAdmin) {
      this.deleteKriteriumFromAdminTemplate();
    } else if (this.property) {
      this.deleteKriteriumFromPropertyChecklist();
    } else {
      this.deleteKriteriumFromChecklistTemplate();
    }
  }

  private deleteKriteriumFromAdminTemplate() {
    this.api.deleteKriteriumAdminTemplate(this.checklist.levels[this.level].kriterien[this.kriterium].id, this.checklist, this.checklist.levels[this.level])
      .subscribe(checklist => {
        this.kriteriumDeleted.emit(checklist);
      }, err => {
        this.toast.presentToast(8000, 'Das Kriterium konnte nicht gelöscht werden.', 'Erneut versuchen')
          .then(toast => {
            if (toast.role === 'cancel') {
              this.delete();
            }
          });
      });
  }
  private deleteKriteriumFromChecklistTemplate() {
    this.api.deleteKriteriumChecklistTemplate(this.checklist.levels[this.level].kriterien[this.kriterium].id, this.checklist, this.checklist.levels[this.level])
      .subscribe(checklist => {
        this.kriteriumDeleted.emit(checklist);
      }, err => {
        this.toast.presentToast(8000, 'Das Kriterium konnte nicht gelöscht werden.', 'Erneut versuchen')
          .then(toast => {
            if (toast.role === 'cancel') {
              this.delete();
            }
          });
      });
  }
  private deleteKriteriumFromPropertyChecklist() {
    this.api.deleteKriteriumPropertyChecklist(this.checklist.levels[this.level].kriterien[this.kriterium].id, this.checklist, this.checklist.levels[this.level], this.property)
      .subscribe(checklist => {
        this.kriteriumDeleted.emit(checklist);
      }, err => {
        this.toast.presentToast(8000, 'Das Kriterium konnte nicht gelöscht werden.', 'Erneut versuchen')
          .then(toast => {
            if (toast.role === 'cancel') {
              this.delete();
            }
          });
      });
  }

  onDelete(bar: FivLoadingProgressBar) {
    bar.load();
    const l = this.checklist.levels[this.level];
    const k = this.checklist.levels[this.level].kriterien[this.kriterium];
    this.api.deletePictoFromKriterium(this.checklist.id, l.id, k.id, k.picto.id, this.isAdmin)
      .subscribe(() => {
        bar.complete({});
        this.image = null;
        this.imageData = null;
      }, err => {
        bar.unload();
      });
  }

  loadImage() {
    const kriterium = this.checklist.levels[this.level].kriterien[this.kriterium];
    if (kriterium.picto) {
      this.api.getPictoBase64(kriterium.picto.id, this.isAdmin)
        .pipe(
          map(image => this.dom.bypassSecurityTrustResourceUrl(`data:${image.type};base64,${image.data}`)),
          tap(image => console.log('image', image)),
          tap(image => this.imageData = image),
        ).subscribe(() => {
          console.log('loaded image');
        }, err => console.log('couldnt load image', err));
    }
  }

  unloadImage() {
    this.image = null;
    this.imageData = null;
  }

  reloadChecklist() {
    if (this.isAdmin) {
      this.api.getAdminChecklist(this.checklist.id)
        .subscribe(checklist => this.fivChange.emit(checklist));
    } else if (this.property) {
      this.api.getChecklistOfProperty(this.property.id, this.checklist.id)
        .subscribe(checklist => this.fivChange.emit(checklist));
    } else {
      this.api.getChecklist(this.checklist.id)
        .subscribe(checklist => this.fivChange.emit(checklist));
    }
  }

  changeLabel(editable: EditableComponent) {
    if (this.isAdmin && !this.property) {
      this.updateAdminTemplateKriterium(editable);
    } else if (!this.isAdmin && !this.property) {
      this.updateChecklisteTemplateKriterium(editable);
    } else if (!this.isAdmin && this.property) {
      this.updatePropertyChecklistKriterium(editable);
    }
  }
  updatePropertyChecklistKriterium(editable: EditableComponent): any {
    const level = this.checklist.levels[this.level];
    this.api.updatePropertyChecklistKriterium(this.checklist.id, this.property.id, level.id, level.kriterien[this.kriterium].id, editable.getValue())
      .subscribe(checklist => this.onTitleChanged(checklist, editable), err => {
        this.onTitleChangeError(err, editable);
      });
  }

  updateChecklisteTemplateKriterium(editable: EditableComponent): any {
    const level = this.checklist.levels[this.level];
    this.api.updateChecklistTemplateKriterium(this.checklist.id, level.id, level.kriterien[this.kriterium].id, editable.getValue())
      .subscribe(checklist => this.onTitleChanged(checklist, editable), err => {
        this.onTitleChangeError(err, editable);
      });
  }
  updateAdminTemplateKriterium(editable: EditableComponent): any {
    const level = this.checklist.levels[this.level];
    this.api.updateAdminTemplateKriterium(this.checklist.id, level.id, level.kriterien[this.kriterium].id, editable.getValue())
      .subscribe(checklist => this.onTitleChanged(checklist, editable), err => {
        this.onTitleChangeError(err, editable);
      });
  }

  onTitleChangeError(err: any, editable: EditableComponent) {
    this.toast.presentToast(8000, 'Der Prüfpunkt konnte nicht geändert werden.', 'OK');
    editable.reset();
  }

  onTitleChanged(checklist: Checklist, editable: EditableComponent) {
    editable.reset();
    this.fivChange.emit(checklist);
  }

  async openGallery() {
    const modal = await this.modal.create({
      component: PictosPage
    });

    await modal.present();

    const { data } = await modal.onDidDismiss();
    if (data) {
      this.imageData = this.dom.bypassSecurityTrustResourceUrl(`data:${data.type};base64,${data.data}`);
      if (this.property) {
        this.api.addPictoPropertyChecklist(data.id, this.property, this.checklist, this.checklist.levels[this.level].id, this.checklist.levels[this.level].kriterien[this.kriterium].id)
          .subscribe((image) => {
            console.log('successfully added picto', image);
          }, err => {
            console.log(err);
            this.toast.error(8000, 'Das Symbolbild konnte nicht geladen werden. Bitte versuchen Sie es später erneut.', 'OK');
            this.imageData = null;
          });
      } else {
        this.api.addPictoToKriterium(this.checklist.id, this.checklist.levels[this.level].id, this.checklist.levels[this.level].kriterien[this.kriterium].id, data.id, this.isAdmin)
          .subscribe((image) => {
            console.log('successfully added picto', image);
          }, err => {
            console.log(err);
            this.toast.error(8000, 'Das Symbolbild konnte nicht geladen werden. Bitte versuchen Sie es später erneut.', 'OK');
            this.imageData = null;
          });
      }
    }
  }

  addPictoToChecklist() {

  }
}
