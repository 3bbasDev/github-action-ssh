import { FivLoadingProgressBar } from '@fivethree/core';
import { ToastService } from './../../services/toast.service';
import { PropertyChecklistAddComponent } from './../../components/property-checklist-add/property-checklist-add.component';
import { PopoverController, NavController, AlertController } from '@ionic/angular';
import { Component, OnInit, ViewChild, AfterViewInit } from '@angular/core';
import { ActivatedRoute, Router, NavigationExtras } from '@angular/router';
import { map, first, tap, catchError, filter } from 'rxjs/operators';
import { Observable, of } from 'rxjs';
import { Property, Checklist, User, Inspection, CreateTaskResult } from 'shared';
import { DataService } from '../../services/data.service';
import { ApiService } from '../../services/api.service';
import { PropertyChecklistActionsComponent } from '../../components/property-checklist-actions/property-checklist-actions.component';
import * as _ from 'lodash';
import { MatTableDataSource, MatPaginator, MatSort } from '@angular/material';

@Component({
  selector: 'app-property',
  templateUrl: './property.page.html',
  styleUrls: ['./property.page.scss'],
})
export class PropertyPage implements AfterViewInit {

  property: Observable<Property>;
  selectedChecklists: Checklist[];
  allChecklists: Checklist[];
  allUsers: Observable<User[]>;
  propertyUsers: User[];
  selectedUsers: User[] = [];
  tasks: Observable<CreateTaskResult[]>;

  // inspection table setup
  inspections: Observable<Inspection[]>;
  dataSource = new MatTableDataSource<Inspection>();
  taskSource = new MatTableDataSource<CreateTaskResult>();
  displayedColumns: string[] = ['userId', 'criterias', 'results', 'done'];
  taskColumns: string[] = ['name', 'userId', 'pruefkriterien', 'rule', 'startDate', 'active'];
  @ViewChild('inspectionsPager') paginator: MatPaginator;
  @ViewChild('tasksPager') taskPaginator: MatPaginator;
  @ViewChild('inspectionsSort') sort: MatSort;
  @ViewChild('tasksSort') taskSort: MatSort;

  constructor(public route: ActivatedRoute, public dataService: DataService,
    public api: ApiService, public router: Router,
    public popoverCtrl: PopoverController,
    private alertController: AlertController,
    public toast: ToastService, public navCtrl: NavController) {
  }

  ngAfterViewInit(): void {
    console.log(this.paginator, this.taskPaginator, this.sort, this.taskSort);
    this.paginator._intl.itemsPerPageLabel = 'Inspektionen pro Seite';
    this.paginator._intl.firstPageLabel = 'Erste Seite';
    this.paginator._intl.nextPageLabel = 'Nächste Seite';
    this.paginator._intl.previousPageLabel = 'Vorherige Seite';
    this.paginator._intl.lastPageLabel = 'Letzte Seite';
    this.paginator._intl.getRangeLabel = (page: number, pageSize: number, length: number) => {
      const startIndex = page * pageSize;
      const endIndex = startIndex < length ? Math.min(startIndex + pageSize, length) : startIndex + pageSize;
      return `${startIndex + 1} - ${endIndex} von ${length}`;
    };
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;

    this.taskPaginator._intl.itemsPerPageLabel = 'Wiederkehrende Begehungen pro Seite';
    this.taskPaginator._intl.firstPageLabel = 'Erste Seite';
    this.taskPaginator._intl.nextPageLabel = 'Nächste Seite';
    this.taskPaginator._intl.previousPageLabel = 'Vorherige Seite';
    this.taskPaginator._intl.lastPageLabel = 'Letzte Seite';
    this.taskPaginator._intl.getRangeLabel = (page: number, pageSize: number, length: number) => {
      const startIndex = page * pageSize;
      const endIndex = startIndex < length ? Math.min(startIndex + pageSize, length) : startIndex + pageSize;
      return `${startIndex + 1} - ${endIndex} von ${length}`;
    };
    this.taskSource.paginator = this.taskPaginator;
    this.taskSource.sort = this.taskSort;
  }


  ionViewWillEnter() {
    const id = this.route.snapshot.paramMap.get('id');
    this.property = this.api.getProperty(id);
    this.setup();
  }

  setup() {
    this.property.subscribe(property => {
      this.api.getChecklistsOfProperty(property.id)
        .subscribe(cs => {
          this.selectedChecklists = cs;
        });
      this.dataService.loadChecklists().subscribe(cs => {
        this.allChecklists = cs;
      });

      this.allUsers = this.dataService.loadUsers()
        .pipe(map(users => users.filter(user => user.role !== 'ROLE_MITARBEITER')));
      this.api.getPropertyUsers(property.id)
        .subscribe(users => {
          this.selectedUsers = users;
          this.propertyUsers = users;
        });

      this.inspections = this.api.getInspectionsOfProperty(property.id);
      this.inspections.subscribe(inspections => this.dataSource.data = inspections);
      this.tasks = this.api.getTasksOfProperty(property.id)
        .pipe(
          map(result => result.tasks)
        );
      this.tasks
        .subscribe(tasks => this.taskSource.data = tasks);
    });
  }

  editProperty(property) {
    this.router.navigate(['properties/edit'], {
      queryParams: {
        property: property.id
      }
    });
  }

  deleteProperty(property: Property) {
    this.api.deleteProperty(property.id)
      .subscribe(() => {
        this.router.navigate(['properties']);
        this.toast.success(4000, `Immobilie ${property.name} erfolgreich gelöscht`, 'OK');
      }, err => {
        this.onError();
      });
  }

  selectChecklists() {
    this.property
      .pipe(first())
      .subscribe(property => {
        this.router.navigate(['/checklists'], { queryParams: { property: property.id } });
      });
  }

  link(checklist: Checklist, property: Property) {
    this.api.linkChecklistToProperty(checklist, property).subscribe(res => {
      this.api.getChecklistsOfProperty(property.id)
        .subscribe(cs => {
          this.selectedChecklists = cs;
        });

    }, err => {
      console.log('error linking user to propety', err);
      this.onError();
    });
  }

  deleteChecklistFromProperty(checklist: Checklist, property: Property) {
    this.api.unlinkChecklistFromProperty(checklist, property).subscribe(data => {
      this.toast.presentToast(8000, `${checklist.name} erfolgreich aus ${property.name} entfernt.`, 'OK');
      this.api.getChecklistsOfProperty(property.id)
        .subscribe(cs => {
          this.selectedChecklists = cs;
        });

    }, err => {
      this.onUnLinkError(checklist, property);
    });
  }

  navigateToChecklist(property: Property, checklist: Checklist): any {
    const params: NavigationExtras = {
      queryParams: {
        property: property.id
      }
    };
    this.router.navigate(['checklists', checklist.id], params);
  }

  navigateToUser(user: User): any {
    this.router.navigate(['users', user.id]);
  }

  onError() {
    this.toast.presentToast(8000, 'Ein unbekannter Fehler ist aufgetreten. Sollte der Fehler weiterhin auftreten, benachrichtigen Sie bitte einen Administrator.', 'Zurück zu Übersicht').then(toast => {
      if (toast.role === 'cancel') {
        this.navCtrl.navigateBack('properties');
      }
    });
  }
  onLinkError(checklist: Checklist, property: Property) {
    this.toast.presentToast(8000, `Die Checkliste ${checklist.name} konnte der Immobilie ${property.name} nicht zugeordnet werden. Sollte der Fehler weiterhin auftreten benchrichtigen Sie bitte inen Administrator.`, 'Erneut versuchen').then(toast => {
      if (toast.role === 'cancel') {
        this.link(checklist, property);
      }
    });
  }
  onMultipleLinkError() {
    this.toast.presentToast(8000, `Benutzer konnten nicht zugeordnet werden. Sollte der Fehler weiterhin auftreten benchrichtigen Sie bitte inen Administrator.`, 'OK');
  }
  onUnLinkError(checklist: Checklist, property: Property) {
    this.toast.presentToast(8000, `Die Checkliste ${checklist.name} konnte nicht aus der Immobilie ${property.name} entfernt werden. Sollte der Fehler weiterhin auftreten benchrichtigen Sie bitte inen Administrator.`, 'Erneut versuchen').then(toast => {
      if (toast.role === 'cancel') {
        this.deleteChecklistFromProperty(checklist, property);
      }
    });
  }

  zaehlerChanged(event) {
    console.log('zähler changed', event);
  }

  onSelect(event) {
    console.log('zähler changed', event);
  }

  selectUserChanged(ev: boolean, property: Property, bar: FivLoadingProgressBar) {
    if (!ev && !this.usersEqual(this.propertyUsers, this.selectedUsers)) {
      bar.load();
      this.api.linkMultipleUsersToProperty(this.selectedUsers, property)
        .pipe(
          catchError(err => {
            bar.unload();
            this.onMultipleLinkError();
            return this.propertyUsers;
          }),
          tap((users) => bar.complete(users))
        ).subscribe();
    }
  }

  changeUsersComplete(users: User[]) {
    this.propertyUsers = users;
  }

  compareUser(o1: User, o2: User) {
    return o1.id === o2.id;
  }

  usersEqual(x: User[], y: User[]) {
    let equal = true;
    if (x.length === y.length) {
      x.forEach((user) => {
        const inY = y.some(u => u.id === user.id);
        if (!inY) {
          equal = false;
        }
      });
    } else {
      equal = false;
    }

    return equal;

  }

  async confirmDeletion(prop: Property) {
    const alert = await this.alertController.create({
      header: 'Löschen bestätigen',
      message: `Immobilie ${prop.name} wirklich löschen?`,
      buttons: [
        {
          text: 'Abbrechen',
          role: 'cancel',
          cssClass: 'secondary',
          handler: () => {
          }
        }, {
          text: 'Löschen',
          handler: () => {
            this.deleteProperty(prop);
          }
        }
      ]
    });

    await alert.present();
  }

  navigateToInspection(event) {
    this.router.navigate(['inspections', event.id]);
  }

  navigateToTask(event, property: Property) {
    this.router.navigate(['task', event.id], { queryParams: { propertyId: property.id } });
  }

  navigateToInspections() {
    this.router.navigate(['inspections']);
  }

}
