package de.fivethree.immoapps.backend.service;

import de.fivethree.immoapps.backend.domain.inspection.Inspection;
import de.fivethree.immoapps.backend.domain.property.Property;
import de.fivethree.immoapps.backend.domain.task.Task;
import de.fivethree.immoapps.backend.domain.user.AdditionalUserInfo;
import de.fivethree.immoapps.backend.domain.user.Role;
import de.fivethree.immoapps.backend.domain.user.RoleName;
import de.fivethree.immoapps.backend.domain.user.User;
import de.fivethree.immoapps.backend.exceptions.*;
import de.fivethree.immoapps.backend.model.payload.req.user.CreateHausverwalterRequest;
import de.fivethree.immoapps.backend.model.payload.req.user.CreateUserRequest;
import de.fivethree.immoapps.backend.model.payload.req.user.UpdateUserRequest;
import de.fivethree.immoapps.backend.model.payload.res.user.GetUsersOfHausverwalterResponse;
import de.fivethree.immoapps.backend.repository.PropertyRepository;
import de.fivethree.immoapps.backend.repository.checklist.AdminChecklistTemplateRepository;
import de.fivethree.immoapps.backend.repository.checklist.AdminPictoRepository;
import de.fivethree.immoapps.backend.repository.RoleRepository;
import de.fivethree.immoapps.backend.repository.UserRepository;
import de.fivethree.immoapps.backend.repository.inspection.InspectionRepository;
import de.fivethree.immoapps.backend.repository.task.TaskRepository;
import de.fivethree.immoapps.backend.security.SecurityFacade;
import de.fivethree.immoapps.backend.util.ModelMapper;
import org.apache.commons.lang3.RandomStringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Set;

@Service
@Transactional
public class UserService {

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private RoleRepository roleRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private AdminChecklistTemplateRepository adminChecklistTemplateRepo;

    @Autowired
    private AdminPictoRepository adminPictoRepo;

    @Autowired
    private UserMailService userMailService;

    @Autowired
    private SecurityFacade securityFacade;

    @Autowired
    private InspectionRepository inspectionRepo;

    @Autowired
    private PropertyRepository propertyRepo;

    @PreAuthorize("hasRole('HAUSVERWALTER') or hasRole('MITARBEITER') or hasRole('USER')")
    public User getCurrentHausverwalter() {
        return userRepository.findByIdAndFetchMitarbeiterAndFetchAdditionalInfo(getHausverwalterId());
    }

    @PreAuthorize("hasRole('HAUSVERWALTER') or hasRole('MITARBEITER') or hasRole('USER') or hasRole('ADMIN')")
    public User getCurrentUser() {
        return userRepository.getOne(securityFacade.getCurrentUser().getId());
    }

    @PreAuthorize("hasRole('HAUSVERWALTER') or hasRole('USER') or hasRole('MITARBEITER')")
    public User getUserWithHisPropertiesAndFetchAllDetails() {
        if (securityFacade.hasRole(RoleName.ROLE_MITARBEITER) || securityFacade.hasRole(RoleName.ROLE_HAUSVERWALTER)) {
            return userRepository.findByIdAndFetchOwnPropertiesAndEveryDetail(getHausverwalterId());
        } else if (securityFacade.hasRole(RoleName.ROLE_USER)) {
            return userRepository.findByIdAndFetchPropertiesAndEveryDetail(securityFacade.getCurrentUser().getId());
        }

        return null;
    }

    public User createNewHausverwalter(CreateHausverwalterRequest createHausverwalterReq) {
        if (userRepository.existsByEmail(createHausverwalterReq.getEmail())) {
            throw new EmailAlreadyExistingException(createHausverwalterReq.getEmail());
        }

        String randomPassword = RandomStringUtils.random(8, true, true);

        User user = new User(createHausverwalterReq.getFirstname(), createHausverwalterReq.getLastname(),
                createHausverwalterReq.getEmail(), passwordEncoder.encode(randomPassword));

        Role userRole = roleRepository.findByName(RoleName.ROLE_HAUSVERWALTER)
                .orElseThrow(() -> new AppException("Hausverwalter Role not set."));

        user.setRoles(Collections.singleton(userRole));

        if (createHausverwalterReq.getAdditionalInfo() != null) {
            AdditionalUserInfo userInfo = new AdditionalUserInfo(
                    user,
                    createHausverwalterReq.getAdditionalInfo().getCompanyName(),
                    createHausverwalterReq.getAdditionalInfo().getCity(),
                    createHausverwalterReq.getAdditionalInfo().getZip(),
                    createHausverwalterReq.getAdditionalInfo().getStreetAndNo(),
                    createHausverwalterReq.getAdditionalInfo().getTelephone(),
                    createHausverwalterReq.getAdditionalInfo().getWebsite(),
                    createHausverwalterReq.getAdditionalInfo().getFax());

            user.setAdditionalUserInfo(userInfo);
        }

        //get all admin checklists and add them as templates to this new hausverwalter
        user.setChecklistTemplates(ModelMapper.mapAdminChecklistTemplatesToChecklistTemplates(
                this.adminChecklistTemplateRepo.findAll(), user));

        //get all admin pictos and add them as hausverwalter pictos to this new hausverwalter
        user.setHausverwalterPictos(ModelMapper.mapAdminPictosToHausverwalterPictos(
                this.adminPictoRepo.findAll(), user));

        User hausverwalter = userRepository.save(user);

        this.userMailService.sendRegistrationMail(hausverwalter.getEmail(), hausverwalter.getFullName(), randomPassword);

        return hausverwalter;
    }

    public User updateUser(Long userId, UpdateUserRequest updateUserRequest) {

        if (securityFacade.getCurrentUser().getId().equals(userId)) {
            // the user wants to update himself -> which is fine.
            User userToEdit = userRepository.getUserByIdAndFetchAdditionalInfo(userId);

            if (userRepository.existsByEmailAndIdNot(updateUserRequest.getEmail(), userId)) {
                throw new EmailAlreadyExistingException(updateUserRequest.getEmail());
            }

            if (securityFacade.hasRole(userToEdit, RoleName.ROLE_HAUSVERWALTER)) {
                ModelMapper.fillHausverwalterInfo(userToEdit, updateUserRequest);
            } else {
                ModelMapper.fillUserInfo(userToEdit, updateUserRequest);
            }

            return this.userRepository.save(userToEdit);
        } else if (securityFacade.hasRole(RoleName.ROLE_HAUSVERWALTER)
                || securityFacade.hasRole(RoleName.ROLE_MITARBEITER)) {
            User usertoEdit = userRepository.findByIdAndHausverwalterOrVorgesetzter(userId,
                    getHausverwalterId());

            if (usertoEdit == null) {
                throw new EntityNotFoundException(userId, "User");
            }

            if (userRepository.existsByEmailAndIdNot(updateUserRequest.getEmail(), userId)) {
                throw new EmailAlreadyExistingException(updateUserRequest.getEmail());
            }

            //will never happen but let's check it anyways.
            //a hausverwalter is only allowed to change an employee and a hausmeister
            if (securityFacade.hasRole(usertoEdit, RoleName.ROLE_HAUSVERWALTER) ||
                    securityFacade.hasRole(usertoEdit, RoleName.ROLE_ADMIN)) {
                throw new NotAuthorizedException("Sie haben keine Berechtigung, um diese Aktion auszuführen");
            }

            ModelMapper.fillUserInfo(usertoEdit, updateUserRequest);

            return this.userRepository.save(usertoEdit);
        } else if (securityFacade.hasRole(RoleName.ROLE_ADMIN)) {
            User usertoEdit = userRepository.getOne(userId);

            if (usertoEdit == null) {
                throw new EntityNotFoundException(userId, "User");
            }

            if (userRepository.existsByEmailAndIdNot(updateUserRequest.getEmail(), userId)) {
                throw new EmailAlreadyExistingException(updateUserRequest.getEmail());
            }

            //an admin is only allowed to edit a hausverwalter
            if (!securityFacade.hasRole(usertoEdit, RoleName.ROLE_HAUSVERWALTER)) {
                throw new NotAuthorizedException("Sie haben keine Berechtigung, um diese Aktion auszuführen");
            }

            ModelMapper.fillHausverwalterInfo(usertoEdit, updateUserRequest);

            return this.userRepository.save(usertoEdit);
        }

        throw new NotAuthorizedException("Sie haben keine Berechtigung, um diese Aktion auszuführen");
    }

    @PreAuthorize("hasRole('HAUSVERWALTER') or hasRole('MITARBEITER')")
    public GetUsersOfHausverwalterResponse getUsersAndEmployeesForHausverwalter() {
        User hausverwalter = userRepository.findByIdAndFetchUsersAndFetchMitarbeiter(getHausverwalterId());

        return new GetUsersOfHausverwalterResponse(ModelMapper.mapUsers(hausverwalter.getUsers()),
                ModelMapper.mapUsers(hausverwalter.getMitarbeiter()));
    }

    @PreAuthorize("hasRole('HAUSVERWALTER') or hasRole('MITARBEITER')")
    public User getUserForEmployeeOrForHausverwalter(Long id) {
        User user = userRepository.findByIdAndHausverwalterOrVorgesetzter(id, getHausverwalterId());

        if (user == null) {
            throw new EntityNotFoundException(id ,"User");
        }

        return user;
    }

    @PreAuthorize("hasRole('HAUSVERWALTER') or hasRole('MITARBEITER')")
    public User createNewEmployee(CreateUserRequest createUserRequest) {
        if (userRepository.existsByEmail(createUserRequest.getEmail())) {
            throw new EmailAlreadyExistingException(createUserRequest.getEmail());
        }

        User hausverwalter = userRepository.getOne(getHausverwalterId());
        String randomPassword = RandomStringUtils.random(8, true, true);

        // Creating employee account
        User user = new User(createUserRequest.getFirstname(), createUserRequest.getLastname(),
                createUserRequest.getEmail(), passwordEncoder.encode(randomPassword));

        Role userRole = roleRepository.findByName(RoleName.ROLE_MITARBEITER)
                .orElseThrow(() -> new AppException("Mitarbeiter Role not set."));

        user.setRoles(Collections.singleton(userRole));
        user.setVorgesetzter(hausverwalter);

        User result = userRepository.save(user);

        this.userMailService.sendRegistrationMailMitarbeiter(user.getEmail(), user.getFullName(),
                hausverwalter.getFullName(), randomPassword);

        return result;
    }

    @PreAuthorize("hasRole('HAUSVERWALTER') or hasRole('MITARBEITER') or hasRole('ADMIN')")
    public void deleteUser(Long id) {
        if (securityFacade.hasRole(RoleName.ROLE_HAUSVERWALTER)
                || securityFacade.hasRole(RoleName.ROLE_MITARBEITER)) {
            User userToDelete = userRepository.findByIdAndHausverwalterOrVorgesetzterAndFetchProperties(id,
                    getHausverwalterId());

            if (userToDelete == null) {
                throw new EntityNotFoundException(id, "User");
            }

            //will never happen but let's check it anyways.
            if (securityFacade.hasRole(userToDelete, RoleName.ROLE_HAUSVERWALTER) ||
                    securityFacade.hasRole(userToDelete, RoleName.ROLE_ADMIN)
                    || userToDelete.getId().equals(securityFacade.getCurrentUser().getId())) {
                throw new NotAuthorizedException("Sie haben keine Berechtigung, um diese Aktion auszuführen");
            }

            this.cleanUpDeletedUser(userToDelete);
            userToDelete.setDeleted(true);
            userRepository.save(userToDelete);
        } else if (securityFacade.hasRole(RoleName.ROLE_ADMIN)) {
            User userToDelete = userRepository.getOne(id);

            if (userToDelete == null) {
                throw new EntityNotFoundException(id, "User");
            }

            //an admin is only allowed to delete a hausverwalter
            if (!securityFacade.hasRole(userToDelete, RoleName.ROLE_HAUSVERWALTER)) {
                throw new NotAuthorizedException("Sie haben keine Berechtigung, um diese Aktion auszuführen");
            }

            userRepository.delete(userToDelete);
        }
    }

    @PreAuthorize("hasRole('HAUSVERWALTER') or hasRole('MITARBEITER')")
    private void cleanUpDeletedUser(User deletedUser) {
        //delete the open insepctions of the user
        Set<Inspection> openInspections = this.inspectionRepo.findAllOpenByUser(deletedUser);
        if (openInspections != null && openInspections.size() > 0) {
            this.inspectionRepo.deleteAll(openInspections);
        }

        //remove the user from all his properties.
        Set<Property> userProperties = deletedUser.getProperties();
        if (userProperties != null && userProperties.size() > 0) {
            for (Property userProperty : userProperties) {
                userProperty.getUsers().remove(deletedUser);
            }
            this.propertyRepo.saveAll(userProperties);
        }
    }

    @PreAuthorize("hasRole('HAUSVERWALTER') or hasRole('MITARBEITER') or hasRole('ADMIN')")
    public void resetUserPassword(Long id) {
        if (securityFacade.hasRole(RoleName.ROLE_HAUSVERWALTER)
                || securityFacade.hasRole(RoleName.ROLE_MITARBEITER)) {
            User userToReset = userRepository.findByIdAndHausverwalterOrVorgesetzter(id, getHausverwalterId());

            if (userToReset == null) {
                throw new EntityNotFoundException(id, "User");
            }

            //will never happen but let's check it anyways.
            if (securityFacade.hasRole(userToReset, RoleName.ROLE_HAUSVERWALTER) ||
                    securityFacade.hasRole(userToReset, RoleName.ROLE_ADMIN)) {
                throw new NotAuthorizedException("Sie haben keine Berechtigung, um diese Aktion auszuführen");
            }

            String randomPassword = RandomStringUtils.random(8, true, true);

            userToReset.setPassword(passwordEncoder.encode(randomPassword));
            userRepository.save(userToReset);
            userMailService.sendPasswordResetMail(userToReset.getEmail(), userToReset.getFullName(), randomPassword);
        } else if (securityFacade.hasRole(RoleName.ROLE_ADMIN)) {
            User userToReset = userRepository.getOne(id);

            if (userToReset == null) {
                throw new EntityNotFoundException(id, "User");
            }

            //an admin is only allowed to reset a hausverwalter password
            if (!securityFacade.hasRole(userToReset, RoleName.ROLE_HAUSVERWALTER)) {
                throw new NotAuthorizedException("Sie haben keine Berechtigung, um diese Aktion auszuführen");
            }

            String randomPassword = RandomStringUtils.random(8, true, true);

            userToReset.setPassword(passwordEncoder.encode(randomPassword));
            userRepository.save(userToReset);
            userMailService.sendPasswordResetMail(userToReset.getEmail(), userToReset.getFullName(), randomPassword);
        }
    }

    @PreAuthorize("hasRole('HAUSVERWALTER') or hasRole('MITARBEITER')")
    public User createNewHausmeister(CreateUserRequest createUserRequest) {
        if (userRepository.existsByEmail(createUserRequest.getEmail())) {
            throw new EmailAlreadyExistingException(createUserRequest.getEmail());
        }

        User hausverwalter = userRepository.getOne(getHausverwalterId());

        String randomPassword = RandomStringUtils.random(8, true, true);

        // Creating user's account
        User user = new User(createUserRequest.getFirstname(), createUserRequest.getLastname(),
                createUserRequest.getEmail(), passwordEncoder.encode(randomPassword));

        Role userRole = roleRepository.findByName(RoleName.ROLE_USER)
                .orElseThrow(() -> new AppException("User Role not set."));

        user.setRoles(Collections.singleton(userRole));
        user.setHausverwalter(hausverwalter);

        User result = userRepository.save(user);

        this.userMailService.sendRegistrationMailHausmeister(user.getEmail(), user.getFullName(),
                hausverwalter.getFullName(), randomPassword);

        return result;
    }

    @PreAuthorize("hasRole('ADMIN')")
    public Set<User> getAllHausverwalters() {
        Role userRole = roleRepository.findByName(RoleName.ROLE_HAUSVERWALTER)
                .orElseThrow(() -> new AppException("User Role not set."));

        return userRepository.getAllUsersByRoleAndFetchAdditionalInfo(userRole);
    }

    @PreAuthorize("hasRole('ADMIN')")
    public User getHausverwalterById(Long id) {
        Role userRole = roleRepository.findByName(RoleName.ROLE_HAUSVERWALTER)
                .orElseThrow(() -> new AppException("User Role not set."));

        User user = userRepository.getUserByIdAndRoleAndFetchAdditionalInfo(id, userRole);

        if (user == null) {
            throw new EntityNotFoundException(id, "User");
        }

        return user;
    }

    @PreAuthorize("hasRole('HAUSVERWALTER') or hasRole('MITARBEITER') or hasRole('USER')")
    private Long getHausverwalterId() {
        if (securityFacade.hasRole(RoleName.ROLE_MITARBEITER)) {
            User mitarbeiter = userRepository.getOne(securityFacade.getCurrentUser().getId());
            return mitarbeiter.getVorgesetzter().getId();
        } else if (securityFacade.hasRole(RoleName.ROLE_USER)) {
            User hausmeister = userRepository.getOne(securityFacade.getCurrentUser().getId());
            return hausmeister.getHausverwalter().getId();
        }

        return securityFacade.getCurrentUser().getId();
    }
}
