package de.fivethree.immoapps.backend.service;

import de.fivethree.immoapps.backend.domain.checklist.ChecklistPruefkriterium;
import de.fivethree.immoapps.backend.domain.property.Property;
import de.fivethree.immoapps.backend.domain.task.Task;
import de.fivethree.immoapps.backend.domain.task.TaskPruefkriterium;
import de.fivethree.immoapps.backend.domain.task.TaskScheduleOption;
import de.fivethree.immoapps.backend.domain.user.RoleName;
import de.fivethree.immoapps.backend.domain.user.User;
import de.fivethree.immoapps.backend.exceptions.CriteriaNotAllowedException;
import de.fivethree.immoapps.backend.exceptions.EntityNotFoundException;
import de.fivethree.immoapps.backend.exceptions.UserPropertyException;
import de.fivethree.immoapps.backend.model.payload.req.task.CreateTaskRequest;
import de.fivethree.immoapps.backend.model.payload.req.task.UpdateTaskRequest;
import de.fivethree.immoapps.backend.repository.checklist.ChecklistPruefkriteriumRepository;
import de.fivethree.immoapps.backend.repository.task.TaskRepository;
import de.fivethree.immoapps.backend.repository.task.TaskScheduleOptionRepository;
import de.fivethree.immoapps.backend.repository.UserRepository;
import de.fivethree.immoapps.backend.security.SecurityFacade;
import de.fivethree.immoapps.backend.util.ModelMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;

@Service
@Transactional
public class TaskService {

    @Autowired
    private TaskRepository taskRepository;

    @Autowired
    private PropertyService propertyService;

    @Autowired
    private UserService userService;

    @Autowired
    private TaskScheduleOptionRepository taskScheduleOptionRepository;

    @Autowired
    private ChecklistPruefkriteriumRepository checklistPruefkriteriumRepo;

    @Autowired
    private SecurityFacade securityFacade;

    @Autowired
    private UserRepository userRepo;

    @PreAuthorize("hasRole('HAUSVERWALTER') or hasRole('MITARBEITER')")
    public List<Task> getTasksOfProperty(Long propertyId) {
        List<Task> ret = new ArrayList<>();
        Property property = this.propertyService.getPropertyByIdAndFetchTasks(propertyId);
        ret.addAll(property.getTasks());
        return ret;
    }

    @PreAuthorize("hasRole('HAUSVERWALTER') or hasRole('MITARBEITER')")
    public Task getTaskByIdAndProperty(Long taskId, Property property) {
        Task task = this.taskRepository.findByIdAndProperty(taskId, property);

        if (task == null) {
            throw new EntityNotFoundException(taskId, "Task");
        }

        return task;
    }

    @PreAuthorize("hasRole('HAUSVERWALTER') or hasRole('MITARBEITER')")
    public Task createTaskForProperty(Long propertyId, CreateTaskRequest createTaskRequest) {
        Property prop = this.propertyService.getPropertyAndBoundUsers(propertyId);
        User user = userService.getUserForEmployeeOrForHausverwalter(createTaskRequest.getAssignedUserId());

        //in case the user is a hausmeister we have to check that he is connected to the property.
        if (securityFacade.hasRole(user, RoleName.ROLE_USER)
                && !prop.getUsers().contains(user)) {
            throw new UserPropertyException("Der Nutzer: " + user.getFullName() + " ist der Immobilie: "
                    + prop.getName() + " nicht zugeordnet");
        }

        User currentUser = userService.getCurrentUser();
        TaskScheduleOption option = taskScheduleOptionRepository.findById(createTaskRequest.getScheduleOptionId())
                .orElseThrow(() -> new EntityNotFoundException(createTaskRequest.getScheduleOptionId(),
                        "TaskScheduleOption"));

        Task task = new Task(prop, createTaskRequest.getName(), createTaskRequest.getActive(), option,
                user, currentUser, createTaskRequest.getStartDate());
        List<TaskPruefkriterium> criterias = getTaskPruefkriterienFromIds(createTaskRequest.getTaskCriterias(), task);
        task.getPruefkriterien().addAll(criterias);

        return taskRepository.save(task);
    }

    @PreAuthorize("hasRole('HAUSVERWALTER') or hasRole('MITARBEITER')")
    public Task updateTaskForProperty(Long propertyId, Long taskId, UpdateTaskRequest updateTaskRequest) {
        Property prop = this.propertyService.getPropertyAndBoundUsers(propertyId);
        User user = userService.getUserForEmployeeOrForHausverwalter(updateTaskRequest.getAssignedUserId());

        //in case the user is a hausmeister we have to check that he is connected to the property.
        if (securityFacade.hasRole(user, RoleName.ROLE_USER)
                && !prop.getUsers().contains(user)) {
            throw new UserPropertyException("Der Nutzer: " + user.getFullName() + " ist der Immobilie: "
                    + prop.getName() + " nicht zugeordnet");
        }

        User currentUser = userService.getCurrentUser();
        TaskScheduleOption option = taskScheduleOptionRepository.findById(updateTaskRequest.getScheduleOptionId())
                .orElseThrow(() -> new EntityNotFoundException(updateTaskRequest.getScheduleOptionId(),
                        "TaskScheduleOption"));

        Task task = this.getTaskByIdAndProperty(taskId, prop);
        task.setName(updateTaskRequest.getName());
        task.setActive(updateTaskRequest.getActive());
        task.setAuftragGeber(currentUser);
        task.setUser(user);
        task.setScheduleOption(option);
        task.setStartDate(updateTaskRequest.getStartDate());
        return this.taskRepository.save(task);
    }

    @PreAuthorize("hasRole('HAUSVERWALTER') or hasRole('MITARBEITER')")
    public void deleteTask(Long propertyId, Long taskId) {
        Property prop = this.propertyService.getPropertyAndBoundUsers(propertyId);
        Task task = this.getTaskByIdAndProperty(taskId, prop);
        this.taskRepository.delete(task);
    }

    private List<TaskPruefkriterium> getTaskPruefkriterienFromIds(List<Long> criteriaIds,
                                                                  Task task) {
        List<TaskPruefkriterium> ret = new ArrayList<>();
        for (Long criteriaId : criteriaIds) {
            ChecklistPruefkriterium criteria = this.checklistPruefkriteriumRepo
                    .findByIdAndFetchEverything(criteriaId);
            this.checkCriteriaAllowed(criteria, criteriaId);
            TaskPruefkriterium taskPruefkriterium = ModelMapper
                    .mapChecklistPruefkriteriumToTaskPruefkriterium(criteria, task);
            ret.add(taskPruefkriterium);
        }

        return ret;
    }

    private void checkCriteriaAllowed(ChecklistPruefkriterium criteria, Long criteriaId) {
        boolean allowed = false;

        if (criteria == null) {
            throw new EntityNotFoundException(criteriaId, "Pruefkriterium");
        }

        if (securityFacade.hasRole(RoleName.ROLE_HAUSVERWALTER)) {
            allowed = criteria.getLevel().getChecklist().getProperty()
                    .getHausverwalter().getId().equals(securityFacade.getCurrentUser().getId());
        } else if (securityFacade.hasRole(RoleName.ROLE_MITARBEITER)) {
            User mitarbeiter = userRepo.getOne(securityFacade.getCurrentUser().getId());
            allowed = criteria.getLevel().getChecklist().getProperty()
                    .getHausverwalter().getId().equals(mitarbeiter.getVorgesetzter().getId());
        } else if (securityFacade.hasRole(RoleName.ROLE_USER)) {
            allowed = criteria.getLevel().getChecklist().getProperty()
                    .getUsers().contains(userRepo.getOne(securityFacade.getCurrentUser().getId()));
        }

        if (!allowed) {
            throw new CriteriaNotAllowedException("Sie haben keine Berechtigung, um auf dieses Kriterium zuzugreifen.");
        }
    }
}
