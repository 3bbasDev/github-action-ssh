import { NavigateBackward } from '@fivethree/ngxs-ionic-router-plugin';
import { State, Action, StateContext, Selector, createSelector } from '@ngxs/store';
import { Inspection, AddInspectionResultPayload } from 'shared';
import {
    GetInspections,
    CreateInspection,
    InspectionCreatedSuccesful,
    CreateInspectionResult,
    SaveInspectionResultLocally,
    SaveInspectionLocally,
    DeleteInspectionResultLocally,
    GetClosedInspections
} from './inspections.actions';
import { tap } from 'rxjs/operators';
import { InspectionsService } from '@services/inspections.service';

export class InspectionsStateModel {
    inspections?: Inspection[];
    closedInspections?: Inspection[];

    localInspectionResults?: { [inspectionId: string]: AddInspectionResultPayload[] };
}

@State<InspectionsStateModel>({
    name: 'inspections',
    defaults: {
        inspections: [],
        closedInspections: [],
        localInspectionResults: {

        }
    }
})
export class InspectionsState {

    static getInspection(inspectionId: number) {
        return createSelector([InspectionsState], (state: InspectionsStateModel) => {
            return state.inspections.find(inspection => inspection.id === inspectionId);
        });
    }
    static getClosedInspection(inspectionId: number) {
        return createSelector([InspectionsState], (state: InspectionsStateModel) => {
            return state.closedInspections.find(inspection => inspection.id === inspectionId);
        });
    }

    @Selector()
    static inspections(state: InspectionsStateModel) { return state.inspections; }

    @Selector()
    static closedInspections(state: InspectionsStateModel) { return state.closedInspections; }

    @Selector()
    static inspectionsCount(state: InspectionsStateModel) { return state.inspections.length; }

    constructor(private inspectionsService: InspectionsService) { }

    @Action(GetInspections)
    getInspections(ctx: StateContext<InspectionsStateModel>) {
        return this.inspectionsService.loadInspections()
            .pipe(tap(inspections => ctx.patchState({ inspections })));
    }

    @Action(GetClosedInspections)
    getClosedInspections(ctx: StateContext<InspectionsStateModel>) {
        return this.inspectionsService.loadClosedInspections()
            .pipe(tap(closedInspections => ctx.patchState({ closedInspections })));
    }

    @Action(CreateInspection)
    createInspection(ctx: StateContext<InspectionsStateModel>, action: CreateInspection) {
        return this.inspectionsService.addInspection(action.payload)
            .pipe(
                tap(inspection => ctx.dispatch(new SaveInspectionLocally(inspection))),
                // tap(inspection => ctx.dispatch(new InspectionCreatedSuccesful(inspection))) // bar complete not working
            );
    }

    @Action(CreateInspectionResult)
    createInspectionResult(ctx: StateContext<InspectionsStateModel>, action: CreateInspectionResult) {
        ctx.dispatch(new SaveInspectionResultLocally(action.payload, action.inspectionId));
        return this.inspectionsService.addInspectionResult(action.inspectionId, action.payload)
            .pipe(
                tap(inspection => ctx.dispatch(new SaveInspectionLocally(inspection))),
                tap(() => ctx.dispatch(new DeleteInspectionResultLocally(action.payload, action.inspectionId)))
            );
    }

    @Action(SaveInspectionLocally)
    saveInspectionLocally(ctx: StateContext<InspectionsStateModel>, action: SaveInspectionLocally) {
        let inspections = Object.assign([], ctx.getState().inspections);
        const inspectionIndex = inspections.findIndex(inspection => inspection.id === action.payload.id);
        if (inspectionIndex === -1) {
            inspections = [...inspections, action.payload];
        } else {
            inspections[inspectionIndex] = action.payload;
        }
        ctx.patchState({ inspections });
    }

    @Action(SaveInspectionResultLocally)
    saveInspectionResultLocally(ctx: StateContext<InspectionsStateModel>, { inspectionId, payload }: SaveInspectionResultLocally) {
        const localInspectionResults = Object.assign({}, ctx.getState().localInspectionResults);
        let inspectionResults = Object.assign([], localInspectionResults[inspectionId]);
        if (inspectionResults) {
            const inspectionIndex = inspectionResults.findIndex(a => a.pruefkriteriumId === payload.pruefkriteriumId);
            if (inspectionIndex === -1) {
                inspectionResults = [...inspectionResults, payload];
            } else {
                inspectionResults[inspectionIndex] = payload;
            }
        } else {
            inspectionResults = [payload];
        }
        localInspectionResults[inspectionId] = inspectionResults;
        ctx.patchState({ localInspectionResults });
    }

    @Action(DeleteInspectionResultLocally)
    deleteInspectionResultLocally(ctx: StateContext<InspectionsStateModel>, { inspectionId, payload }: DeleteInspectionResultLocally) {
        const localInspectionResults = Object.assign({}, ctx.getState().localInspectionResults);
        let inspectionResults = Object.assign([], localInspectionResults[inspectionId]);
        if (inspectionResults) {
            inspectionResults = inspectionResults.filter(a => a.pruefkriteriumId != payload.pruefkriteriumId);
            localInspectionResults[inspectionId] = inspectionResults;
            return ctx.dispatch({ localInspectionResults });
        }
    }

    /**
    * Events
    */

    @Action(InspectionCreatedSuccesful)
    onInspectionCreatedSuccesful(ctx: StateContext<InspectionsStateModel>, action: InspectionCreatedSuccesful) {
        ctx.dispatch(new NavigateBackward(['/inspect', action.payload.id]));
    }
}
