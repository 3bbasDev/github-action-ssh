import { CreateChecklistPayload } from './../../../../../shared/types/types';
import { FivStepper, FivLoadingProgressBar, FivStepContent } from '@fivethree/core';
import { LevelComponent } from './../../components/level/level.component';
import { DataService } from '@services/data.service';
import { NavController, AlertController } from '@ionic/angular';
import { ApiService } from './../../services/api.service';
import { Component, OnInit, ChangeDetectorRef, ViewChild, ViewChildren, QueryList } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { first, map, scan } from 'rxjs/operators';
import { Checklist, Category, User, Property } from 'shared';
import { ToastService } from '@services/toast.service';
import { FormGroup, FormBuilder, Validators } from '@angular/forms';
import { Store } from '@services/store/store.service';
import { EditableComponent } from '@components/editable/editable.component';
import { Subscription } from 'rxjs';

@Component({
  selector: 'app-checklist-edit',
  templateUrl: './checklist-edit.page.html',
  styleUrls: ['./checklist-edit.page.scss'],
})
export class ChecklistEditPage {

  checklistInstance: Checklist;
  addLevelForm: FormGroup;
  categories: Category[];
  currentUser: User;
  property: Property;

  @ViewChild('stepper') stepper: FivStepper;
  @ViewChildren(LevelComponent) levels: QueryList<LevelComponent> = new QueryList();

  constructor(private api: ApiService,
    private route: ActivatedRoute,
    private toast: ToastService,
    private navCtrl: NavController,
    private formBuilder: FormBuilder,
    private change: ChangeDetectorRef,
    public data: DataService,
    private store: Store,
    private alertController: AlertController) {
    this.setupForm();
  }

  setupForm() {
    this.addLevelForm = this.formBuilder.group({
      name: ['', [Validators.minLength(3), Validators.required]],
    });
  }

  ionViewWillEnter() {
    this.store.select('user').subscribe(user => {
      this.currentUser = user;
      if (!user) {
        this.onError();
      }
    });

    const id = this.route.snapshot.paramMap.get('id');
    const property = this.route.snapshot.queryParamMap.get('property');
    if (id && !property) {
      if (this.currentUser.role === 'ROLE_ADMIN') {
        this.loadAdminChecklist(id);
      } else {
        this.loadChecklistTemplate(id);
      }
    } else if (id && property) {
      this.loadPropertyChecklist(id, property);
    }
  }

  ionViewDidLeave() {
  }

  loadChecklistTemplate(checklist) {
    this.api.getChecklist(checklist)
      .subscribe(template => {
        this.checklistInstance = template;
        this.data.loadCategories().subscribe(cats => {
          this.categories = cats;
        });
      }, err => { this.onError(); });
  }

  loadAdminChecklist(checklist: string) {
    this.api.getAdminChecklist(checklist)
      .subscribe(template => {
        this.checklistInstance = template;
        this.data.loadCategories().subscribe(cats => {
          this.categories = cats;
        });
      }, err => { this.onError(); });
  }

  loadPropertyChecklist(checklist: string, property: string) {
    this.api.getChecklistOfProperty(property, checklist)
      .subscribe(template => {
        this.checklistInstance = template;
        this.data.loadCategories().subscribe(cats => {
          this.categories = cats;
        });
      }, err => { this.onError(); });

    this.api.getProperty(property)
      .subscribe(p => {
        this.property = p;
      });
  }

  onError() {
    this.toast.presentToast(8000, 'Ein unbekannter Fehler ist aufgetreten. Sollte der Fehler weiterhin auftreten, benachrichtigen Sie bitte einen Administrator.', 'Zurück zu Übersicht').then(toast => {
      if (toast.role === 'cancel') {
        this.navCtrl.navigateBack('checklists');
      }
    });
  }

  stepClick(index, stepper: FivStepper) {
    stepper.open(index);
  }

  addLevel(bar: FivLoadingProgressBar, stepper: FivStepper) {
    let sub;
    if (this.currentUser.role === 'ROLE_ADMIN') {
      sub = this.addLevelAdminTemplate();
    } else if (this.property) {
      sub = this.addLevelPropertyChecklist();
    } else {
      sub = this.addLevelChecklistTemplate();
    }
    bar.load();

    sub.subscribe(checklist => {
      bar.complete(checklist);
    }, err => {
      this.toast.presentToast(8000, 'Prüfbereich konnte nicht hinzugefügt werden.', 'Erneut versuchen')
        .then(toast => {
          if (toast.role === 'cancel') {
            this.addLevel(bar, this.stepper);
          }
        });
      bar.unload();
    });

  }

  addLevelAdminTemplate() {
    return this.api.addLevelAdminTemplate({ name: this.addLevelForm.value.name }, this.checklistInstance);
  }

  addLevelChecklistTemplate() {
    return this.api.addLevelChecklistTemplate({ name: this.addLevelForm.value.name }, this.checklistInstance);
  }

  addLevelPropertyChecklist() {
    return this.api.addLevelPropertyChecklist({ name: this.addLevelForm.value.name }, this.checklistInstance, this.property);
  }


  levelAddComplete(param: Checklist, stepper: FivStepper) {
    stepper.close(this.checklistInstance.levels.length, param);
  }

  checklistChanged(checklist: Checklist) {
    this.checklistInstance = checklist;
    this.change.detectChanges();

  }

  kriteriumAdded(data: { checklist: Checklist, name: string }) {
    this.checklistInstance = data.checklist;

    this.change.detectChanges();
    const index = this.checklistInstance.levels.findIndex(level => level.name === data.name);
    this.stepper.open(index);
  }

  kriteriumDeleted(data: { checklist: Checklist, name: string }) {
    // data.checklist.levels = data.checklist.levels.sort((a, b) => a.id - b.id);
    // data.checklist.levels.forEach(level => {
    //   level.kriterien = level.kriterien.sort((a, b) => a.id - b.id);
    // });
    this.checklistInstance = data.checklist;
    const index = this.checklistInstance.levels.findIndex(level => level.name === data.name);
    this.change.detectChanges();
    this.stepper.open(index);
  }

  deleteChecklist() {
    if (this.currentUser.role === 'ROLE_ADMIN' && !this.property) {
      this.deleteAdminChecklistTemplate();
    } else if (this.currentUser.role !== 'ROLE_ADMIN' && !this.property) {
      this.deleteChecklisteTemplate();
    } else if (this.currentUser.role !== 'ROLE_ADMIN' && this.property) {
      this.deleteChecklistFromProperty();
    }

  }

  private deleteChecklistFromProperty() {
    this.api.unlinkChecklistFromProperty(this.checklistInstance, this.property)
      .subscribe(res => {
        this.toast.presentToast(8000, `${this.checklistInstance.name} erfolgreich gelöscht`, 'OK');
        this.navCtrl.navigateBack('checklists');
        this.data.reloadChecklists();
      });
  }

  private deleteChecklisteTemplate() {
    this.api.deleteChecklist(this.checklistInstance)
      .subscribe(res => {
        this.toast.presentToast(8000, `${this.checklistInstance.name} erfolgreich gelöscht`, 'OK');
        this.navCtrl.navigateBack('checklists');
        this.data.reloadChecklists();
      });
  }

  private deleteAdminChecklistTemplate() {
    this.api.deleteAdminChecklist(this.checklistInstance)
      .subscribe(res => {
        this.toast.presentToast(8000, `Vorlage ${this.checklistInstance.name} erfolgreich gelöscht`, 'OK');
        this.navCtrl.navigateBack('admin-checklists');
        this.data.reloadAdminChecklists();
      });
  }

  async presentAlertConfirm() {
    const alert = await this.alertController.create({
      header: 'Löschen bestätigen',
      message: `Checkliste <strong>${this.checklistInstance.name}</strong> wirklich löschen? Dieser Schritt kann nicht rückgängig gemacht werden.`,
      buttons: [
        {
          text: 'Abbrechen',
          role: 'cancel',
          cssClass: 'secondary'
        }, {
          text: 'Löschen',
          handler: () => {
            this.deleteChecklist();
          }
        }
      ]
    });

    await alert.present();
  }

  async undefaultConfirm() {
    const alert = await this.alertController.create({
      header: 'Änderung bestätigen',
      message: `Damit wird die Checkliste nicht weiterhin als Standardcheckliste verwendet.`,
      buttons: [
        {
          text: 'Abbrechen',
          role: 'cancel',
          cssClass: 'secondary'
        }, {
          text: 'Bestätigen',
          handler: () => {
            this.undefault();
          }
        }
      ]
    });

    await alert.present();
  }

  undefault() {
    const payload: CreateChecklistPayload = {
      name: this.checklistInstance.name,
      defaultChecklist: false
    };
    if (this.currentUser.role === 'ROLE_ADMIN' && !this.property) {
      this.api.updateAdminTemplate(this.checklistInstance.id, payload)
        .subscribe(checklist => this.checklistChanged(checklist), err => {
          this.onError();
        });
    } else if (this.currentUser.role !== 'ROLE_ADMIN' && !this.property) {
      this.api.updateChecklistTemplate(this.checklistInstance.id, payload)
        .subscribe(checklist => this.checklistChanged(checklist), err => {
          this.onError();
        });
    }
  }

  default() {
    const payload: CreateChecklistPayload = {
      name: this.checklistInstance.name,
      defaultChecklist: true
    };
    if (this.currentUser.role === 'ROLE_ADMIN' && !this.property) {
      this.api.updateAdminTemplate(this.checklistInstance.id, payload)
        .subscribe(checklist => this.checklistChanged(checklist), err => {
          this.onError();
        });
    } else if (this.currentUser.role !== 'ROLE_ADMIN' && !this.property) {
      this.api.updateChecklistTemplate(this.checklistInstance.id, payload)
        .subscribe(checklist => this.checklistChanged(checklist), err => {
          this.onError();
        });
    }
  }


  stepClose(event: { index: number, param: Checklist }, stepper: FivStepper) {
    if (event.param && this.addLevelForm.value.name && this.addLevelForm.value.name.length > 0) {
      this.checklistInstance = event.param;
      const index = this.checklistInstance.levels.findIndex(l => l.name === this.addLevelForm.value.name);
      setTimeout(() => {
        stepper.open(index);
      }, 200);
      this.setupForm();
    }

  }

  kriteriumChanged(checklist: Checklist) {
    console.log('reload checklist', checklist);
    const state = this.getState();
    this.checklistInstance = checklist;
    console.log('state before change', state);
    this.change.detectChanges();
    this.setState(state);
    console.log('state after change', this.getState());

    if (this.currentUser.role === 'ROLE_ADMIN') {
      this.data.reloadAdminChecklists();
    } else if (this.property) {
      // do nothing?
    } else {
      this.data.reloadChecklists();
    }
  }

  getState() {
    return { steps: this.stepper.steps.toArray(), levels: this.levels.toArray() };
  }

  setState(state: { steps: FivStepContent[], levels: LevelComponent[] }) {
    this.stepper.steps
      .forEach((newStep, i) => {
        newStep.step.timingFunction = '0ms';
        newStep.isOpen = state.steps[i].step.isOpen;
        newStep.fivDidOpen
          .pipe(first())
          .subscribe(() => {
            newStep.step.timingFunction = null;
          });
      });

    this.levels
      .forEach((level, i) => {
        level.ex.timingFunction = '0ms';
        level.ex.isOpen = state.levels[i].ex.isOpen;
        level.ex.fivDidOpen
          .pipe(first())
          .subscribe(() => {
            level.ex.timingFunction = null;
          });
      });
  }

  changeTitle(editable: EditableComponent) {
    console.log('change title here', editable.getValue());
    if (this.currentUser.role === 'ROLE_ADMIN' && !this.property) {
      this.updateAdminTemplate(editable);
    } else if (this.currentUser.role !== 'ROLE_ADMIN' && !this.property) {
      this.updateChecklisteTemplate(editable);
    } else if (this.currentUser.role !== 'ROLE_ADMIN' && this.property) {
      this.updateChecklistFromProperty(editable);
    }
  }
  updateChecklistFromProperty(editable: EditableComponent): any {
    this.api.updatePropertyChecklist(this.checklistInstance.id, this.property.id, editable.getValue())
      .subscribe(checklist => this.onTitleChanged(checklist, editable), err => {
        this.onTitleChangeError(err, editable);
      });
  }

  updateChecklisteTemplate(editable: EditableComponent): any {
    this.api.updateChecklistTemplate(this.checklistInstance.id, editable.getValue())
      .subscribe(checklist => this.onTitleChanged(checklist, editable), err => {
        this.onTitleChangeError(err, editable);
      });
  }
  updateAdminTemplate(editable: EditableComponent): any {
    this.api.updateAdminTemplate(this.checklistInstance.id, editable.getValue())
      .subscribe(checklist => this.onTitleChanged(checklist, editable), err => {
        this.onTitleChangeError(err, editable);
      });
  }

  onTitleChangeError(err: any, editable: EditableComponent) {
    this.toast.presentToast(8000, 'Der Name der Checkliste konnte nicht geändert werden.', 'OK');
    editable.reset();
  }

  onTitleChanged(checklist: Checklist, editable: EditableComponent) {
    editable.reset();
    this.checklistChanged(checklist);
  }

  openAll() {
    this.checklistInstance.levels.forEach((l, i) => {
      this.stepper.open(i);
    });
  }

  closeAll() {
    this.checklistInstance.levels.forEach((l, i) => {
      this.stepper.close(i);
    });
  }

}

